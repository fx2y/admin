@_ECHO_ON

# Provide your GitHub and Docker Hub namepspaces
GITHUB_NS=
IMG_NS=
kubectl create ns dev
kubectl create ns prod
git clone https://github.com/$GITHUB_NS/go-sample-app.git
hub clone https://github.com/springone-tour-2020-cicd/go-sample-app.git && cd go-sample-app
hub fork --remote-name origin
git ls-remote --heads | grep scenario
# Fill this in with the branch name (e.g. BRANCH=scenario-1-finished)
BRANCH=
git checkout --track origin/$BRANCH
find . -name *.yaml -exec sed -i "s//springone-tour-2020-cicd//${GITHUB_NS}/g" {} +
find . -name *.yaml -exec sed -i "s/ springone-tour-2020-cicd/ ${IMG_NS}/g" {} +
git add -A
git commit -m "Reset from branch $BRANCH, updated namespaces"
git branch -m master old-master
git branch -m $BRANCH master
git push -f -u origin master
git push -f origin old-master
git branch -d old-master
kubectl create ns argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
kubectl get all -n argocd
kubectl api-resources --api-group argoproj.io
kubectl get applications,appprojects -n argocd
yq m <(kubectl get cm argocd-cm -o yaml -n argocd) <(cat << EOF
data:
kustomize.buildOptions: --load_restrictor none
EOF
) | kubectl apply -f -
kubectl rollout status deployment/argocd-server -n argocd
kubectl port-forward --address 0.0.0.0 svc/argocd-server 8080:80 -n argocd 2>&1 > /dev/null &
kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server -o name | cut -d'/' -f 2
argocd login localhost:8080 --insecure --username admin
GENERAL
Application Name: go-sample-app-dev
Project: default

SOURCE
Repository URL: https://github.com/<GITHUB_NS>/go-sample-app.git
Revision: HEAD
Path: ops/overlays/dev

DESTINATION
Cluster: https://kubernetes.default.svc
Namespace: dev
Note on `Cluster` field configuration: we are deploying the sample app into the same cluster where Argo CD is installed, but you can also attach other clusters as targets for app deployments.

As a point of information, the CLI command to create the same application would be:
argocd app create go-sample-app-dev        --repo https://github.com/${GITHUB_NS}/go-sample-app.git        --path ops/overlays/dev        --dest-namespace dev        --dest-server https://kubernetes.default.svc

## Sync and review the application

You should see a tile appear representing the application you just created.
Refresh the page if it doesn't appear on its own.

The app tile status should be "OutOfSync", reflected also in the yellow coloring.
This means that the ops files declare a state that is not reflected in the cluster, which is expected since the application has not yet been deployed to the cluster.
Since we left the 'Sync Policy' at the default value of 'Manual', Argo CD is not automatically applying the ops files to Kubernetes.

Click on the Sync icon on the app tile, then click 'Synchronize' in the pop-up.
The tile should turn green, and the status should show that the app is healthy (green heart) and synced (green circle with checkmark).

## Explore the deployment

Click on the box that represents your app deployment.
You should see a visual representation of the Kubernetes resources related to the app's deployment.
Mouse over the corresponding boxes to see a pop-up with additional info; click on the boxes to see even more information.

Validate the resources in Kubernetes:
kubectl get all -n dev
kubectl get endpoints -n dev
kubectl get endpointslice -n dev
kubectl port-forward service/go-sample-app 8081:8080 -n dev 2>&1 > /dev/null &
APP_PID=$!
curl localhost:8081
kill ${APP_PID} && wait $!
argocd app set go-sample-app-dev --sync-policy automated
yq m -i -x ops/overlays/dev/kustomization.yaml - <<EOF
images:
- name: ${IMG_NS}/go-sample-app  # used for Kustomize matching
newTag: 1.0.0
EOF
git commit -am "Switched back to 1.0.0"
git push
kubectl rollout status deployment/go-sample-app -n dev
kubectl port-forward service/go-sample-app 8081:8080 -n dev 2>&1 > /dev/null &
APP_PID=$!
curl localhost:8081
kill ${APP_PID} && wait $!
#echo "namePrefix: dev-" >> ops/overlays/dev/kustomization.yaml
yq w -i ops/overlays/dev/kustomization.yaml namePrefix dev-
git commit -am 'Add prefix dev-'
git push origin master
argocd app list
argocd app get go-sample-app-dev
> GROUP  KIND        NAMESPACE  NAME               STATUS     HEALTH   HOOK  MESSAGE
> apps   Deployment  dev        go-sample-app      OutOfSync  Healthy        ignored (requires pruning)
>        Service     dev        go-sample-app      OutOfSync  Healthy        ignored (requires pruning)
>        Service     dev        dev-go-sample-app  Synced     Healthy        service/dev-go-sample-app created
> apps   Deployment  dev        dev-go-sample-app  Synced     Healthy        deployment.apps/dev-go-sample-app created

Enabling pruning tells Argo CD to delete resources that are not reflected in the declared state (ops files).
By default, and as a safety mechanism, automatic pruning is disabled.
You can enable it for all syncs, or you can manually apply it for a single sync.
Go back to the UI and click on 'SYNC'.
In the pop-up, check the option to prune, then hit Synchronize.
You should see the two older resources disappear.

Once again, check the app status using the CLI:
argocd app get go-sample-app-dev
mkdir /workspace/go-sample-app/cicd/argo
cd  /workspace/go-sample-app/cicd/argo

cat <<EOF >argo-deploy-dev.yaml
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
name: go-sample-app-dev
EOF

echo "$(argocd app get go-sample-app-dev -o yaml | yq r - spec | yq p - spec)" >> argo-deploy-dev.yaml
sed 's/dev/prod/g' argo-deploy-dev.yaml > argo-deploy-prod.yaml
yq r -C argo-deploy-prod.yaml
kubectl apply -f argo-deploy-prod.yaml -n argocd
kubectl rollout status deployment/prod-go-sample-app -n prod
kubectl port-forward service/prod-go-sample-app 8081:8080 -n prod 2>&1 > /dev/null &
APP_PID=$!
curl localhost:8081
kubectl logs $(kubectl get pods -n prod -o jsonpath="{.items[0].metadata.name}") -n prod
kill ${APP_PID} && wait $!
argocd app set go-sample-app-prod --self-heal
kubectl delete deploy prod-go-sample-app -n prod
git add -A
git commit -m 'Changes from the Argo CD scenario'
git push origin master
