@_ECHO_OFF

cd ~/workspace-demo


# Check which process is on port 8080:
#lsof -i :8080 | grep LISTEN

clear
@_ECHO_ON

# Sample app

ls
go run hello-server.go 2>&1 > /dev/null &
curl localhost:8080
pkill hello-server && wait $!

export environment=sandbox; go run hello-server.go

# Build with Dockerfile

bat Dockerfile

docker build . -t go-demo-app
docker images | grep go-demo-app

docker tag go-demo-app $IMG_NS/go-demo-app:1.0.0
docker push $IMG_NS/go-demo-app:1.0.0

# Initial deploy

mkdir ops
kubectl create deployment go-demo-app --image=$IMG_NS/go-demo-app:1.0.0 -n dev --dry-run=client -o yaml > ops/deployment.yaml
k create service clusterip go-demo-app --tcp=8080:8080 -n dev --dry-run=client -o yaml > ops/service.yaml

tree .
cd ops
yq r -C deployment.yaml
yqc service.yaml
k apply -f .
kns dev
k rollout status deploy/go-demo-app
k get all
k port-forward svc/go-demo-app 8080 2>&1 > /dev/null&
curl localhost:8080
pkill kubectl && wait $!

# Promote to prod

k create deployment go-demo-app --image=$IMG_NS/go-demo-app:1.0.0 -n prod --dry-run=client -o yaml > ops/deployment-prod.yaml
k create service clusterip go-demo-app --tcp=8080:8080 -n prod --dry-run=client -o yaml > ops/service-prod.yaml
k apply -f deployment-prod.yaml
k apply -f service-prod.yaml
kns prod
k rollout status deploy/go-demo-app
k port-forward svc/go-demo-app 8080 2>&1 > /dev/null &
curl localhost:8080
pkill kubectl && wait $!
